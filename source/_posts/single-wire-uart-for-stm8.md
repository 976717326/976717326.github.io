---
title: stm8单线半双工使用
date: 2017-12-22 10:13:35
toc: true
categories: 
- 嵌入式
tags: 
- 原创
- stm8
- 单线半双工
---

## 单线半双工是什么

### 基本概念
一般来说，按照信息的传输方向，串行通讯方式可以分为：
- **单工通讯：** 如果在通讯过程的任意时刻，信息只能由一方A传到另一方B，则称为单工通讯。
```flow
st=>operation: A
e=>operation: B
st(right)->e
```

- **半双工通讯：**如果在任意时刻，信息既可由一方A传到另一方B，也可由B传到A，但是存在限制条件：在任意时刻，通讯中只能存在某一个方向的传输（A->B或者B->A这两个方向取其一），称为半双工通讯。
```sequence
A->B: 一次通讯
B-->A: 另一次通讯
```

- **全双工通讯：**如果在任意时刻，同时允许A到B和B到A的双向传输，则称为全双工通讯。
```sequence
A->B: 双向同
B->A: 时进行
```

<!---more--->

### 比较
对比这三种不同的通讯方式，其优势与劣势也是明显的：
> - 单工通讯：通讯方向只能是单向的，接收方无法向发送方反馈信息；但实际的占用的硬件资源（如引线的数量）可能会比较少。
> - 半双工通讯：通讯可以做到双向，但是存在分时复用问题，需要进行总线的仲裁以解决通讯时的冲突问题。
> - 全双工通讯：可以同时双向通讯，效率高，但是实际使用的引线的数量可能会比较多。

不同场景，按照实际的需求，使用的通讯方式也不一样，单工通讯的适合只需一个方向传输的应用场景，而全双工适合双向高效传输的场景。而半双工折衷了以上两种传输方式，即：既满足了双工的需求，又尽量节省了硬件资源。所谓的节省了硬件资源，就是在传输过程中，A→B时使用的引脚与A←B时使用的引脚是一样的。
一个典型的例子就是两个使用RS485协议通讯的节点，双向通讯时共用两根相同的信号线。任意时刻只能存在一个方向的信号传输。

### 单线半双工

为了保证信号的质量，RS485使用了差分信号线来传输信号，但是一般来说，RS485芯片除了差分信号线，还需要分别的RX信号引脚、TX信号引脚以及控制传输方向的引脚。总的来说，占用的硬件资源不算少。
而单线半双工则是对以上功能进行了大幅简化。只是用一根线进行双向传输，不需要额外的传输方向控制引脚。这样做的话，信号传输的抗干扰能力下降，并且需要MCU额外处理一些工作，但是大大节省了硬件资源。所以单线半双工适合MCU处理功能相对强大，传输距离短，干扰小的情况。
## STM8的单线半双工

### 手册说明
在`STM8S003F3P6`中，只有`UART1`提供了单线半双工的功能。
{% qnimg uart1-single-wire.png title:单线半双工说明 extend:?imageView2/2/w/600 %}
在其数据手册中，对单线半双工有以下的描述：
{% qnimg single-wire-dscript.png extend:?imageView2/2/w/600 %}
按照以上说明，可以尝试对stm8进行配置，来使能其提供的单线半双工通信功能。
### STM8单线半双工的实现

- **保持`UART_CR3`中的`LINEN`和`CLKEN`位为0**
- **保持`UART_CR5`中的`SCEN`和`IREN`位为0**

以上两点其实通过复位`UART1`来实现，因为复位之后，这些位都默认为0：
```cpp
UART1_DeInit();	// 复位UART1
```
- **设置`UART_CR5`中的`HDSEL`位为1**

在复位`UART1`之后，需要配置`UART1`的一些基本参数，然后开启单线半双工功能：
```cpp
// 配置9600波特率，8位数据，1位停止位，无奇偶校验，无控制流，发送/接收功能使能
UART1_Init((uint32_t)9600, UART1_WORDLENGTH_8D, UART1_STOPBITS_1,
	UART1_PARITY_NO, UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_TXRX_ENABLE);
UART1_HalfDuplexCmd(ENABLE);	// 开启单线半双工通信功能
```
由于STM8使用`TX`引脚作为单线半双工的通讯引脚，所以在此之前，要对该引脚进行配置。对需要特别注意的是，一般情况下，为了提高GPIO的驱动能力，往往将IO口配制成**推挽输出模式**，但是这里`TX`引脚需要配置成**开漏输出模式**。

```cpp
GPIO_Init(GPIOD, GPIO_PIN_5, GPIO_MODE_OUT_OD_HIZ_FAST);	// 配置成开漏输出
```

> 之所以使用开漏输出模式，而不用推挽输出模式，原因是明显的：
> 1. 当IO被设置为推挽输出时，如果软件输出0和1，在对应的引脚上，会直接输出相应的0和1。即完全不要外部电阻提供上下拉即可输出目标电平。
> 2. 当IO被配置为**正真的**开漏输出时，如果：（1）软件输出0，在对应的引脚上，会直接输出0；（2）如果软件输出1，则会在对应的引脚上，表现为高阻态。除非加入**外部上拉电阻**，才能输出想要的高电平。
> 3. 当IO被配置为**模拟的**的开漏输出时（即MCU内部弱上拉，并钳位），其表现与带外部上拉的真正的开楼模式一致。

> 考虑到单线半双工通信模式下，两个通讯设备之间的`TX`引脚是互连的，一旦双方的仲裁没有处理好，并且如果双方的`TX`引脚均配置成推挽输出，则会出现严重后果：双方输出相异的信号（一方输出0，另一方输出1），则导致短路现象。但是如果两个设备如果配置成了开漏输出，则不会出现危险现象：开漏输出具备“线与”功能，只有双方都输出1时，线上才会出现高电平，否则均表现为低电平。这样可以保护电路不被损坏。


- **使用单线半双工通信功能进行通讯**


1.**发送功能**
由于初始化时同时使能了发送和接收功能，所以需要特别注意的是：**在发送的时候需要禁用接收功能，在发送完成之后再开启接收功能，否则会出现自收发的现象。**

```cpp
Comm_RxDiasble();	// 禁用RX功能
UART1_SendData8(data_to_send);	//  写入数据
while(UART1_GetFlagStatus(UART1_FLAG_TXE) == RESET);		// 等待发送完成	==> (1)
Delay_ms(1);	// 延时适当时间	==> (2)
Comm_RxEnable();	// 使能RX功能
```
	
> 关于以上代码，需要注意2点：
> - **关于发送等待的的标志位**
> 发送完成标志其实有2个：`UART1_FLAG_TXE`和`UART1_FLAG_TC`。
> 这两个标志是`UART_SR`寄存器的最高两位，关于这两两个标志位，手册里的解释是：
> {% qnimg uart1-txe-tc-diff.png extend:?imageView2/2/w/600 %}
> 通过上图可以看出：
>     - `TXE`表示数据已经被转移到了移位寄存器，但是并未完全发送到相应的引脚上，也就是说：数据并未完全发送完成。
>     - `TC`表示所有数据已经到达相应的引脚，数据完全发送完成。
>     
>     **问**：可以看出`TC`才是真正的发送完成标志位，那为什么要使用`TXE`标志位呢？
>     **答**：因为 `TC`存在第一次发送数据丢失问题。MCU复位之后，`UART_SR`的复位值是`0xC0`，也就是`TXE`和`TC`标志位都是1，那么首次执行`while(UART1_GetFlagStatus(`**`UART1_FLAG_TC`**`) == RESET);	`这句代码实际是起不到等待发送完成的作用的（`TC`本来就是1）；而`while(UART1_GetFlagStatus(`**`UART1_FLAG_TXE`**`) == RESET);`	实际在手册执行时也不会出问题，因为写入`UART_DR`寄存器可以对该位清零，恰恰`UART1_SendData8(data_to_send);`这句代码就是写入了`UART_DR`寄存器。所以为了确保数据能够发送出去，选择`TXE`作为发送完成的标志判断。
> - **关于发送完成之后的延时等待**
> 注意到`TXE`**并不是**表示数据**完全**转移到了引脚上，所以如果不适当延时而直接开启接收功能，会导致MCU接收到自身发送的数据，从而导致错误。**延时的时间可以根据波特率来确定**。

2.**接收功能**
一般可以轮询接收标志或者开启接收中断，由于轮询的方式效率太低，所以往往不予采用。而中断的方式实时性好，处理也简单：在中断函数里面接收数据即可。
```cpp
if (UART1_GetFlagStatus(UART1_FLAG_RXNE) != RESET)
{
        data_to_rec = UART1_ReceiveData8();
        /* 加入处理接收到的数据的代码 */
} 
```

注意通过以下代码使能接收中断

```cpp
UART1_ITConfig (UART1_IT_RXNE_OR, ENABLE);
```

