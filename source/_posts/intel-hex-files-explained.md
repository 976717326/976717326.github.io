---
title: Intel Hex 文件格式解析
date: 2018-02-26 16:52:19
tags: HEX
categories: 嵌入式
---

> 本文主要~~参考~~翻译了 [Kanda Electronics Blog](https://www.kanda.com/blog/) 中的[博文](https://www.kanda.com/blog/microcontrollers/intel-hex-files-explained/)，如有错误请指正。

一般来说，典型的可下载文件格式有：bin、hex、elf等。bin是纯二进制的文件，而hex是ASCII编码的文本文件。hex文件是可阅读的，固定的格式使其更容易让人理解。Hex的标准格式率先由Intel提出，现已被各公司扩展成了不同的格式标准，但是其基本格式保持不变，下面对其进行分析。

<!---more--->

### Intel Hex 文件格

Hex文件内，每一行记录的格式都是固定的，格式如下：

`:BBAAAATT[DDDDDDDD]CC`

其中：

**`:`**是该行记录的起始标识符（Start Code）

**`BB`**是该行记录的数据字节数（Byte Count）（即DDDDDDDD代表的字节数）

**`AAAA`**是该行记录指定的地址（Address）

**`TT`**是该行记录的记录类型（Record Type）

**`DD`**是该行记录的数据字节（Data），字节数由**BB**域确定，数据域是可选的，由记录类型确定

**`CC`**是该行记录的校验和（Checksum）

**例1**：

**`:` `10`  `0000` `00` `112233445566778899AABBCCDDEEFF00` `F8`**

该行记录的起始标识符为冒号（:），数据字节数为16个（即**0x10**），数据起始地址为0x0000，记录类型为00，数据域为0x112233445566778899AABBCCDDEEFF00，总计16个字节，该行校验和为0xF8。

可以看出，**在文本内，每2个字符代表一个字节**，比如校验和F8代表的是hex形式的0xF8。

> 为了方便理解和阅读，本文例子在各个域之间插入了空格，实际hex文件中并不会出现这些空格。

**例2**：

**`:` `04` `0010` `00` `11223344` `42`**

该行表示有4个字节的数据，数据起始地址为0x0010，数据内容为0x1122344，校验和为0x42。

通过这两个例子，再次详细讨论这些域的作用：

### 起始标识符

即`:`域，该字符标志着每一行记录的开始。在hex文件中，任意一行记录都必须以冒号作为开头。

### 字节数

即**`BB`**域，指定了数据域的数据长度。

取值范围为0x00~0xFF，这就意味着，每一行的数据域最大字节数为255个，最少的情况则为0个，也就是说数据域不是必须的。一般来说，在内存允许连续存储，并且剩余的需要连续存储的数据不少于16个字节的话，该域会被设置成0x10（即每条记录存储16个字节），当然，这不是强制性的，但是大多数编译器都会这么做。

### 地址

即**`AAAA`**域，指定了数据域的起始地址。

取值范围为0x0000~0xFFFF，这就意味着，数据存储容量为64K。显然，如果程序容量被限制到64K是不合理的，所以需要对地址进行扩展，扩展的方法由**记录类型**决定，具体方法见下文。

需要注意的是，在**记录类型**为00时，地址域才有实际的意义。因为此时数据域的内容才真正代表需要写入到内存中的数据。值得注意的是，实际的hex文件中的记录，地址域可能不会按照一定的增长顺序来排列，实际的地址顺序可能是错乱的，但是这并不会影响hex文件的解析和下载。除00以外，其他记录类型均不会向内存写入数据。

### 记录类型

即**`TT`**域，指定了该行的记录类型。

取值范围为00~05。

- **`00`**：该行记录为数据（Data）。数据域的内容需要从地址域指定的起始地址开始写入。
- **`01`**：该行记录为文件终止标识（End of File）。Hex文件结束标志。任何一个hex文件最后一行都是固定的：`:00000001FF`。此时该记录不存在数据域。


- **`02`**：该行记录为扩展段地址（Extended Segment Address）。当需要写入数据的地址超过64K时，如果使用**00**类型的记录是无法满足要求的。这时候需要对地址进行扩展。

  **例3：**

  **`:` ` 02` `0000` `02` `1000` `FD`**

  该记录**地址域**是被忽略的，一般地址域会被设置成**0000**，记录类型**02**后续的2个字节左移**4**位后成为后续数据记录的偏移地址。即0x1000左移4位后变成0x10000。如果该记录之后再出现和**例1**中一样的记录，则实际写入数据的起始地址为：0x10000，而非0x0000。该偏移地址对所有后续的数据记录有效，指导有其他设置偏移地址的记录出现。

  显然，**记录类型02**将地址扩展到了64K*16=1024K=1M。

- **`03`**：该行记录为起始段地址（Start Segment Address）。（待完善。。。）

- **`04`**：该行记录为扩展线性地址（Extended Linear Address）。当需要写入数据的地址超过64K时，还有一种扩展地址的方法，先看以下例子。

  **例4：**

  **`:` `02` `0000` `04` `0001` `F9`**

  该记录**地址域**也是被忽略的，一般地址域会被设置成**0000**，记录类型**04**后续的2个字节左移**16**位后成为后续数据记录的偏移地址。即0x0001左移16位后变成0x10000。如果该记录之后再出现和**例1**中一样的记录，则实际写入数据的起始地址为：0x10000，而非0x0000。该偏移地址对所有后续的数据记录有效，指导有其他设置偏移地址的记录出现。

  显然，**记录类型04**将地址扩展到了64K*2^16=4096M=4G。

- **`05`**：该行记录为起始线性地址（Start Linear Address）。（待完善。。。）

### 数据

即**`DD`**域，指定了该行记录的数据内容（如果存在数据域的话）。

数据的字节数由**字节数**域确定，数据域的内容可能是需要写入到内存中的数据（记录类型为00时），也可能是需要设置的偏移地址（记录类型为02或者04时），如果记录类型为01时，则数据数据域不存在。

### 校验和

即**`CC`**域，指定了该行记录的校验和。

校验方法为：将字节数域到数据域之间的字节数据相加，取相加结果的最低字节（LSB， least significant byte），该字节的补码即为最终的校验和。每一行记录都必须以校验和作为结束。再次回到**例2**，该记录的校验和为0x42，计算过程为：

0x04 + 0x00 + 0x10 + 0x11 + 0x22 + 0x33 +0x44 = 0xBE

0xBE的二进制码为：10111110h

转化为补码：10111110h[原码]→01000001h[反码]→01000010[补码]→0x42

最终得到校验和为0x42.

### 小结

hex文件内，每一行记录格式都是相同的，以冒号（:）开始，随后按照**字节数**、**地址**、**记录类型**、**数据**以及**校验和**的顺序来存储。